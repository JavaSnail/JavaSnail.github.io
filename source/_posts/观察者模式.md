---
title: 观察者模式
date: 2022-05-22 14:11:34
categories: 行为型模式
tags: 设计模式
cover: 	https://refactoring.guru/images/patterns/content/observer/observer.png
---

## 💭 什么是观察者模式?

> 一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。
> 

## 为什么使用观察者模式?

### ☹️问题

假如有两种类型的对象：短视频平台的用户和短视频内容的创作者。用户对某个内容创作者拍摄或者剪辑的视频十分的感兴趣，但是该作者视频更新并没有规律。

这个时候用户可能需要经常打开视频软件来查看自己感兴趣的博主有没有更新视频，可能大多时候是徒劳的浏览。

另一种情况就是视频平台一旦更新视频就立刻推送给所有的用户，但是这种情况下可能受到的大多数推送消息都是会被用户视为垃圾推送，因为很大一部分都是自己不感兴趣的内容。

辣么问题来了，要么用户选择自己每次打开软件搜索自己喜欢的博主查看是否有内容更新；要么让平台实时推送新的视频更新内容供用户筛选。但是这两种方式明显都很没有用户体验。

### 😃 解决方案

既然用户只关心自己感兴趣的内容创作者，那么就可以聚焦关注点。由用户订阅（关注）自己喜欢的博主，当该博主的内容在第一时间更新上传之后，由平台推送给订阅的用户即可。这样既可以避免垃圾推送，又能提升用户体验。

> 拥有一些值得关注的状态的对象通常被称为*目标*（短视频内容的创作者）， 由于它要将自身的状态改变通知给其他对象， 我们也将其称为*发布者* （publisher）。 所有希望关注发布者状态变化的其他对象被称为*订阅者* （subscribers）（短视频平台用户）。
> 

观察者模式建议你为发布者类添加订阅机制， 让每个对象都能订阅或取消订阅发布者事件流。

1. 一个用于存储订阅者对象引用的列表成员变量；
2. 几个用于添加或删除该列表中订阅者的公有方法。

![Observer-parttern](https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/design-partter/Untitled.png)

## 🛠️ 怎么使用观察者模式?

### 观察者模式的结构

![Observer-parttern](https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/design-partter/Untitled%201.png)

**发布者** （Publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。

> 当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。
> 

**订阅者** （Subscriber）： 接口声明了通知接口。 

> 在绝大多数情况下， 该接口仅包含一个 `update`更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。
> 

**具体订阅者** （Concrete Subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。

> 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。
> 

**客户端** （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。

### 实现方式

1. 检查业务逻辑，试着将逻辑拆分为两部分： 1️⃣独立于其他代码的核心功能将作为发布者； 2️⃣其他代码转化为订阅者。
2. 声明订阅者接口。 该接口至少应声明一个 `update`方法。
3. 声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。 
   
    > 发布者必须仅通过订阅者接口与它们进行交互。
    > 
4. 确定存放实际订阅列表的位置并实现订阅方法。
   
    > 通常所有类型的发布者代码看上去都一样， 因此将列表放置在直接扩展自发布者接口的抽象类中是显而易见的。 具体发布者会扩展该类从而继承所有的订阅行为。
    > 
5. 创建具体发布者类。
   
    > 每次发布者发生了重要事件时都必须通知所有的订阅者。
    > 
6. 在具体订阅者类中实现通知更新的方法。
   
    > 1） 绝大部分订阅者需要一些与事件相关的上下文数据。 这些数据可作为通知方法的参数来传递。
    2）但还有另一种选择。 订阅者接收到通知后直接从通知中获取所有数据。 在这种情况下， 发布者必须通过更新方法将自身传递出去。
    3） 另一种不太灵活的方式是通过构造函数将发布者与订阅者永久性地连接起来。
    > 
7. 客户端必须生成所需的全部订阅者， 并在相应的发布者处完成注册工作。

## 什么情况下使用观察者模式?

- 🐞  当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。
  
    > 当你使用图形用户界面类时通常会遇到一个问题。 比如， 你创建了自定义按钮类并允许客户端在按钮中注入自定义代码， 这样当用户按下按钮时就会触发这些代码。
    > 
    > 
    > 观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。 你可在按钮中添加订阅机制， 允许客户端通过自定义订阅类注入自定义代码。
    > 
- 🐞  当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。
  
    > 订阅列表是动态的， 因此订阅者可随时加入或离开该列表。
    > 
    
    核心 Java 程序库中该模式的一些示例：
    
- [java.util.Observer](http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html) / [java.util.Observable](http://docs.oracle.com/javase/8/docs/api/java/util/Observable.html)（极少在真实世界中使用）
- [java.util.EventListener](http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html)的所有实现 （几乎广泛存在于 Swing 组件中）
- [javax.servlet.http.HttpSessionBindingListener](http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html)
- [javax.servlet.http.HttpSessionAttributeListener](http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionAttributeListener.html)
- [javax.faces.event.PhaseListener](http://docs.oracle.com/javaee/7/api/javax/faces/event/PhaseListener.html)