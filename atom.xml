<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="http://www.xuxueli.top/atom.xml" rel="self"/>
  
  <link href="http://www.xuxueli.top/"/>
  <updated>2022-05-22T09:35:59.235Z</updated>
  <id>http://www.xuxueli.top/</id>
  
  <author>
    <name>Charlie Xu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://www.xuxueli.top/2022/05/22/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuxueli.top/2022/05/22/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-05-22T06:11:34.000Z</published>
    <updated>2022-05-22T09:35:59.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="💭-什么是观察者模式"><a href="#💭-什么是观察者模式" class="headerlink" title="💭 什么是观察者模式?"></a>💭 什么是观察者模式?</h2><blockquote><p>一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p></blockquote><h2 id="为什么使用观察者模式"><a href="#为什么使用观察者模式" class="headerlink" title="为什么使用观察者模式?"></a>为什么使用观察者模式?</h2><h3 id="☹️问题"><a href="#☹️问题" class="headerlink" title="☹️问题"></a>☹️问题</h3><p>假如有两种类型的对象：短视频平台的用户和短视频内容的创作者。用户对某个内容创作者拍摄或者剪辑的视频十分的感兴趣，但是该作者视频更新并没有规律。</p><p>这个时候用户可能需要经常打开视频软件来查看自己感兴趣的博主有没有更新视频，可能大多时候是徒劳的浏览。</p><p>另一种情况就是视频平台一旦更新视频就立刻推送给所有的用户，但是这种情况下可能受到的大多数推送消息都是会被用户视为垃圾推送，因为很大一部分都是自己不感兴趣的内容。</p><p>辣么问题来了，要么用户选择自己每次打开软件搜索自己喜欢的博主查看是否有内容更新；要么让平台实时推送新的视频更新内容供用户筛选。但是这两种方式明显都很没有用户体验。</p><h3 id="😃-解决方案"><a href="#😃-解决方案" class="headerlink" title="😃 解决方案"></a>😃 解决方案</h3><p>既然用户只关心自己感兴趣的内容创作者，那么就可以聚焦关注点。由用户订阅（关注）自己喜欢的博主，当该博主的内容在第一时间更新上传之后，由平台推送给订阅的用户即可。这样既可以避免垃圾推送，又能提升用户体验。</p><blockquote><p>拥有一些值得关注的状态的对象通常被称为<em>目标</em>（短视频内容的创作者）， 由于它要将自身的状态改变通知给其他对象， 我们也将其称为<em>发布者</em> （publisher）。 所有希望关注发布者状态变化的其他对象被称为<em>订阅者</em> （subscribers）（短视频平台用户）。</p></blockquote><p>观察者模式建议你为发布者类添加订阅机制， 让每个对象都能订阅或取消订阅发布者事件流。</p><ol><li>一个用于存储订阅者对象引用的列表成员变量；</li><li>几个用于添加或删除该列表中订阅者的公有方法。</li></ol><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/design-partter/Untitled.png" alt="Observer-parttern"></p><h2 id="🛠️-怎么使用观察者模式"><a href="#🛠️-怎么使用观察者模式" class="headerlink" title="🛠️ 怎么使用观察者模式?"></a>🛠️ 怎么使用观察者模式?</h2><h3 id="观察者模式的结构"><a href="#观察者模式的结构" class="headerlink" title="观察者模式的结构"></a>观察者模式的结构</h3><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/design-partter/Untitled%201.png" alt="Observer-parttern"></p><p><strong>发布者</strong> （Publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。</p><blockquote><p>当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。</p></blockquote><p><strong>订阅者</strong> （Subscriber）： 接口声明了通知接口。 </p><blockquote><p>在绝大多数情况下， 该接口仅包含一个 <code>update</code>更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。</p></blockquote><p><strong>具体订阅者</strong> （Concrete Subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。</p><blockquote><p>订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。</p></blockquote><p><strong>客户端</strong> （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p>检查业务逻辑，试着将逻辑拆分为两部分： 1️⃣独立于其他代码的核心功能将作为发布者； 2️⃣其他代码转化为订阅者。</p></li><li><p>声明订阅者接口。 该接口至少应声明一个 <code>update</code>方法。</p></li><li><p>声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。 </p><blockquote><p>发布者必须仅通过订阅者接口与它们进行交互。</p></blockquote></li><li><p>确定存放实际订阅列表的位置并实现订阅方法。</p><blockquote><p>通常所有类型的发布者代码看上去都一样， 因此将列表放置在直接扩展自发布者接口的抽象类中是显而易见的。 具体发布者会扩展该类从而继承所有的订阅行为。</p></blockquote></li><li><p>创建具体发布者类。</p><blockquote><p>每次发布者发生了重要事件时都必须通知所有的订阅者。</p></blockquote></li><li><p>在具体订阅者类中实现通知更新的方法。</p><blockquote><p>1） 绝大部分订阅者需要一些与事件相关的上下文数据。 这些数据可作为通知方法的参数来传递。<br> 2）但还有另一种选择。 订阅者接收到通知后直接从通知中获取所有数据。 在这种情况下， 发布者必须通过更新方法将自身传递出去。<br> 3） 另一种不太灵活的方式是通过构造函数将发布者与订阅者永久性地连接起来。</p></blockquote></li><li><p>客户端必须生成所需的全部订阅者， 并在相应的发布者处完成注册工作。</p></li></ol><h2 id="什么情况下使用观察者模式"><a href="#什么情况下使用观察者模式" class="headerlink" title="什么情况下使用观察者模式?"></a>什么情况下使用观察者模式?</h2><ul><li><p>🐞  当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。</p><blockquote><p>当你使用图形用户界面类时通常会遇到一个问题。 比如， 你创建了自定义按钮类并允许客户端在按钮中注入自定义代码， 这样当用户按下按钮时就会触发这些代码。</p><p>观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。 你可在按钮中添加订阅机制， 允许客户端通过自定义订阅类注入自定义代码。</p></blockquote></li><li><p>🐞  当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。</p><blockquote><p>订阅列表是动态的， 因此订阅者可随时加入或离开该列表。</p></blockquote><p>  核心 Java 程序库中该模式的一些示例：  </p></li><li><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html">java.util.Observer</a> &#x2F; <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observable.html">java.util.Observable</a>（极少在真实世界中使用）</p></li><li><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html">java.util.EventListener</a>的所有实现 （几乎广泛存在于 Swing 组件中）</p></li><li><p><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html">javax.servlet.http.HttpSessionBindingListener</a></p></li><li><p><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionAttributeListener.html">javax.servlet.http.HttpSessionAttributeListener</a></p></li><li><p><a href="http://docs.oracle.com/javaee/7/api/javax/faces/event/PhaseListener.html">javax.faces.event.PhaseListener</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;💭-什么是观察者模式&quot;&gt;&lt;a href=&quot;#💭-什么是观察者模式&quot; class=&quot;headerlink&quot; title=&quot;💭 什么是观察者模式?&quot;&gt;&lt;/a&gt;💭 什么是观察者模式?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一种行为设计模式， 允许你定义一种订阅</summary>
      
    
    
    
    <category term="行为型模式" scheme="http://www.xuxueli.top/categories/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://www.xuxueli.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://www.xuxueli.top/2022/05/22/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuxueli.top/2022/05/22/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-05-22T04:03:50.000Z</published>
    <updated>2022-05-22T09:35:59.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="💭-什么是命令模式"><a href="#💭-什么是命令模式" class="headerlink" title="💭 什么是命令模式"></a>💭 <strong>什么是命令模式</strong></h2><blockquote><p>命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p></blockquote><h2 id="❔-为什么要使用命令模式"><a href="#❔-为什么要使用命令模式" class="headerlink" title="❔ 为什么要使用命令模式"></a>❔ <strong>为什么要使用命令模式</strong></h2><blockquote><p>场景：假如我们正在设计一款文本编辑器，当前的任务是创建一个包含多个按钮的工具栏。</p></blockquote><h3 id="☹️-传统意义上的解决方案"><a href="#☹️-传统意义上的解决方案" class="headerlink" title="☹️ 传统意义上的解决方案"></a>☹️ 传统意义上的解决方案</h3><p><strong>第一步：</strong>我们设计一个按钮类<code>Button</code>，这个按钮类很简洁它不仅可用于工具栏上的按钮，可以用来生成各种对话框的通用按钮。</p><p><strong>第二步：</strong>虽然按钮看上去相似，但是不同的按钮对应着不同的操作（新建、保存、打印），这些不同的功能我们可能考虑到去继承<code>Button</code> 类</p><p>然后由子类去完成按钮点击后的代码。</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/design-partter/Untitled.png" alt="command-parttern"></p><blockquote><p>这么做存在神马问题？</p></blockquote><ol><li>按钮类以一种拙略的方式依赖业务逻辑中的不稳定代码。我们创建了大量的子类，当每次需要修改基类<code>Button</code> 时，都要相应修改所有子类的代码。</li><li>增加重复代码。比如复制、粘贴文本的操作可能会在多个地方被调用，用户可以点击工具栏上的<code>复制</code> 按钮，或者通过右键菜单复制又或者使用<code>Ctrl + C</code> 。程序开始只有工具栏也就说只通过工具栏<code>复制</code> 文本是没有问题的，但是在加上右键菜单和快捷键功能之后，我们就只能将相同的代码再拷贝一份出来放进多个类中。</li></ol><h3 id="😃-良好的解决方案"><a href="#😃-良好的解决方案" class="headerlink" title="😃 良好的解决方案"></a>😃 良好的解决方案</h3><blockquote><p>优秀的软件设计通常会将关注点进行分离， 而这往往会导致软件的分层。</p></blockquote><p>由上面的指导方针自然联想到分层，我们可以让图形界面专注于用户界面的渲染，业务功能方面的专注于凸出自身业务的表达。</p><p>在代码中GUI对象传递一些参数来调用一个业务逻辑对象，这一过程在我们看来是一个对象发送请求给另一个对象。</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/design-partter/command.drawio.png" alt="command-parttern"></p><p>命令模式不建议GUI直接提交这些请求，应该将请求的所有细节（调用的对象、方法名称、参数列表）抽取出来组成命令类，该类中包含一个触发请求的方法。由命令对象连接请求的发出方（GUI对象）和命令的接收方（业务逻辑处理对象）。</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/design-partter/command.drawio_(1).png" alt="command-parttern"></p><blockquote><p>命令模式中抽象出来的命令接口中含有一个没有任何参数的方法，该方法能在不和具体命令类耦合的情况使用同一请求发送者执行不同的命令。</p></blockquote><p>那么我们在调用的时候请求的调用细节是如何进行传递的呢？</p><blockquote><p>使用数据对命令进行预先的配置或者让其能够自行获取数据。通俗一点说就是通过构造函数预先配置调用细节。</p></blockquote><h2 id="🚘-真实世界的类比"><a href="#🚘-真实世界的类比" class="headerlink" title="🚘 真实世界的类比"></a><strong>🚘 真实世界的类比</strong></h2><p>一个风和日丽的下午你走进了一家餐厅，你找了个靠窗的位置坐下这是服务员拿来了菜单，认真记录下了你需要的美食，然后将菜单送到了后厨备餐。这个过程中就像你发送了一份指令让厨师烹饪想吃的美食，可是你并不需要找到厨师。在这个过程中你就是命令的发出者，菜单就是命令对象，厨师就是命令的接收者。你没有和厨师直接直接建立联系，而是通过命令对象将你们联系了起来</p><h2 id="🛠️-怎样使用命令模式"><a href="#🛠️-怎样使用命令模式" class="headerlink" title="🛠️ 怎样使用命令模式"></a>🛠️ 怎样使用命令模式</h2><h3 id="令模式的结构"><a href="#令模式的结构" class="headerlink" title="令模式的结构"></a><strong>令模式的结构</strong></h3><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/design-partter/Untitled%201.png" alt="command-parttern"></p><p><strong>发送者</strong> （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。</p><p><strong>命令</strong> （Command） 接口通常仅声明一个执行命令的方法。</p><p><strong>具体命令</strong> （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。</p><p><strong>接收者</strong> （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。</p><p><strong>客户端</strong> （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p>声明仅有一个执行方法的命令接口。</p></li><li><p>抽取请求并使之成为实现命令接口的具体命令类。</p><blockquote><p>每个类都必须有一组成员变量来保存请求参数和对于实际接收者对象的引用。 所有这些变量的数值都必须通过命令构造函数进行初始化。</p></blockquote></li><li><p>找到担任<strong>发送者</strong>职责的类。</p><blockquote><p>在这些类中添加保存命令的成员变量。 发送者只能通过命令接口与其命令进行交互。 发送者自身通常并不创建命令对象， 而是通过客户端代码获取。</p></blockquote></li><li><p>修改发送者使其执行命令， 而非直接将请求发送给接收者。</p></li><li><p>客户端必须按照以下顺序来初始化对象：</p><ul><li>创建接收者。</li><li>创建命令， 如有需要可将其关联至接收者。</li><li>创建发送者并将其与特定命令关联。</li></ul><h2 id="什么情况下使用命令模式"><a href="#什么情况下使用命令模式" class="headerlink" title="什么情况下使用命令模式"></a>什么情况下使用命令模式</h2><p> 🐞 如果你需要通过操作来参数化对象， 可使用命令模式。</p><blockquote><p>命令模式可将特定的方法调用转化为独立对象。我们可以传递命令本身因为其自身携带了调用的信息。</p></blockquote><p> 🐞 如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。</p><p> 🐞 如果你想要实现操作回滚功能， 可使用命令模式。</p><p> 核心 Java 程序库中的一些示例：</p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">java.lang.Runnable</a> 的所有实现</li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html">javax.swing.Action</a>的所有实现</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;💭-什么是命令模式&quot;&gt;&lt;a href=&quot;#💭-什么是命令模式&quot; class=&quot;headerlink&quot; title=&quot;💭 什么是命令模式&quot;&gt;&lt;/a&gt;💭 &lt;strong&gt;什么是命令模式&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;命令模式是一种行</summary>
      
    
    
    
    <category term="行为型模式" scheme="http://www.xuxueli.top/categories/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://www.xuxueli.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PicGo配置阿里云OSS</title>
    <link href="http://www.xuxueli.top/2022/05/20/PicGo%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91OSS/"/>
    <id>http://www.xuxueli.top/2022/05/20/PicGo%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91OSS/</id>
    <published>2022-05-20T15:55:14.000Z</published>
    <updated>2022-05-22T09:35:59.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PicGo配置阿里云OSS"><a href="#PicGo配置阿里云OSS" class="headerlink" title="PicGo配置阿里云OSS"></a>PicGo配置阿里云OSS</h1><h2 id="选购OSS产品"><a href="#选购OSS产品" class="headerlink" title="选购OSS产品"></a>选购OSS产品</h2><blockquote><p>如果有账号直接登录，没有账号注册一个新的账号,登录阿里云之后选择产品→存储→对象存储OSS</p></blockquote><p>点击直达：<a href="https://www.aliyun.com/product/oss?userCode=6if4uptj">阿里云对象存储</a></p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled.png"></p><blockquote><p>根据自己的需求选择资源包，标准包的价格也比较便宜半年不到五块钱。能满足基础需求后续有需要可以继续续费。</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%201.png"></p><h2 id="创建存储容器"><a href="#创建存储容器" class="headerlink" title="创建存储容器"></a>创建存储容器</h2><blockquote><p>购买完成后进入控制台，进行对象存储管理</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%202.png"></p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%203.png"></p><blockquote><p>选择左侧Bucket列表，点击创建Bucket，填写名称，其他按照默认填写就行了。</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%204.png"></p><h2 id="创建RAM子用户管理存储授权"><a href="#创建RAM子用户管理存储授权" class="headerlink" title="创建RAM子用户管理存储授权"></a>创建RAM子用户管理存储授权</h2><blockquote><p>建议使用RAM用户的AccessKey进行API的访问</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%205.png"></p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%206.png"></p><blockquote><p>创建一个RAM新用户，用于专门管理OSS存储。选择左侧的用户，然后点击创建用户，输入登录名称。确认无误之后提交</p></blockquote><blockquote><p>ps：勾选Open Api调用，这样就会生成该用户的AccessKey ID 和 AccessKey Secret用于后续配置PicGo</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%207.png"></p><blockquote><p>创建完成后记得保存你的AccessKey ID 和 AccessKey Secret,建议下载CSV文件。返回上一页之后就看不到了</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%208.png"></p><blockquote><p>回到用户页，为新创建的用户添加权限。按如下所示进行权限的配置。</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%209.png"></p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%2010.png"></p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><blockquote><p>下载PicGo，下载链接：<a href="https://molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a></p></blockquote><blockquote><ul><li>keyId和KeySecret就是AccessKey ID 和 AccessKey Secret</li></ul></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%2011.png"></p><blockquote><p>存储空间名称填写刚创建的Bucket资源名称</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%2012.png"></p><blockquote><p>存储区域填写下面的地址</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%2013.png"></p><blockquote><p>通过主页面上传图片验证</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/Untitled%2014.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PicGo配置阿里云OSS&quot;&gt;&lt;a href=&quot;#PicGo配置阿里云OSS&quot; class=&quot;headerlink&quot; title=&quot;PicGo配置阿里云OSS&quot;&gt;&lt;/a&gt;PicGo配置阿里云OSS&lt;/h1&gt;&lt;h2 id=&quot;选购OSS产品&quot;&gt;&lt;a href=&quot;#选购</summary>
      
    
    
    
    
    <category term="环境配置" scheme="http://www.xuxueli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习总结</title>
    <link href="http://www.xuxueli.top/2021/03/16/SpringCloud/"/>
    <id>http://www.xuxueli.top/2021/03/16/SpringCloud/</id>
    <published>2021-03-16T12:04:58.000Z</published>
    <updated>2022-05-22T09:35:59.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h2><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><blockquote><p>微服务的提出者：Martin Flower</p><p><a href="https://martinfowler.com/microservices/">https://martinfowler.com/microservices/</a></p></blockquote><blockquote><p>简而言之，微服务架构样式是一种将单个应用程序开发为一<strong>组小型服务的方法</strong>，每个<strong>小型服务</strong>都<strong>在自己的进程中运行</strong>并与轻量级机制（通常是HTTP资源API）进行通信。这些服务<strong>围绕业务功能构建，</strong>并且可以 由全自动部署机制<strong>独立部署</strong>。有一个<strong>集中管理的最低限度的</strong>这些服务，可以用不同的编程语言和使用不同的数据存储技术。</p></blockquote><p>微服务的解读：</p><ul><li>微服务架构只是一个样式，一个风格</li><li>将一个完成的项目，拆分成多个模块去分别开发</li><li>每一个模块都是单独的运行在自己的容器中</li><li>每一个模块都是需要相互通讯的。HTTP、RPC、MQ。</li><li>每一个模块之间是没有依赖关系的，单独部署。</li><li>可以使用多种语言开发不同的模块。</li><li>使用MySQL数据库，Redis，ES去存储数据，也可以使用多个MySQL数据库。</li></ul><p>总结：将复杂臃肿的单体应用进行细粒度的划分，每个拆分出来的服务各自打包部署。</p><h3 id="SpringCloud介绍-1"><a href="#SpringCloud介绍-1" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h3><blockquote><p>SpringCloud是微服务架构落地的一套技术栈</p><p>SpringCloud中的大多数技术都是基于Netflix公司的技术进行二次研发。</p><p>1、SpringCloud的中文社区网站：<a href="http://springcloud.cn/">Spring Cloud中国社区</a></p><p>2、SpringCloud的中文网：<a href="https://www.springcloud.cc/">Spring Cloud中文网-官方文档中文版</a></p><p>八个技术点：</p><ol><li>Eureka - 服务的注册中心</li><li>Ribbon - 服务之间的负载均衡</li><li>Feign - 服务之间的通讯</li><li>Hystrix - 服务的线程隔离以及断路由</li><li>Zuul - 服务网关</li><li>Stream - 实现MQ的使用</li><li>Config - 动态配置</li><li>Sleuth - 服务追踪</li></ol></blockquote><h2 id="服务的注册与发现：Eureka"><a href="#服务的注册与发现：Eureka" class="headerlink" title="服务的注册与发现：Eureka"></a>服务的注册与发现：Eureka</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><p>Eureka就是帮助我们维护所有服务的信息，以便服务之间的相互调用。</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201202170415350.png" alt="image-20201202170415350"></p><h3 id="Euraka的快速入门"><a href="#Euraka的快速入门" class="headerlink" title="Euraka的快速入门"></a>Euraka的快速入门</h3><h4 id="创建EurekaServer"><a href="#创建EurekaServer" class="headerlink" title="创建EurekaServer"></a>创建EurekaServer</h4><blockquote><ol><li>创建一个父工程，并且在父工程中指定SpringCloud的版本，并且将packing修改为pom</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.cloud-version</span>&gt;</span>Hoxton.SR4<span class="tag">&lt;/<span class="name">spring.cloud-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>创建euraka的server,并且导入依赖，在启动类中添加注解，编写yml文件</li></ol></blockquote><p><strong>2.1导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.2启动类添加注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.3编写yml文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span>  <span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 当前的euraka服务是单机版</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><h4 id="创建EurekaClient"><a href="#创建EurekaClient" class="headerlink" title="创建EurekaClient"></a>创建EurekaClient</h4><blockquote><p>1.创建Maven工程，修改为SpringBoot</p></blockquote><blockquote><ol start="2"><li>导入依赖</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>在启动类上添加注解</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(CustomerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>编写配置文件</li></ol></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定Eureka服务地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="comment">#指定服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">CUSTOMER</span></span><br></pre></td></tr></table></figure><h4 id="测试Eureka"><a href="#测试Eureka" class="headerlink" title="测试Eureka"></a>测试Eureka</h4><blockquote><ol><li>创建了一个Search搜索模块，并且注册到Eureka</li></ol></blockquote><blockquote><ol start="2"><li>使用EurekaClient的对象去获取服务信息</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EurekaClient eurekaClient;</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>正常RestTemplate调用即可</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/customer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">customer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.通过eurekaClient获取到SEARCH服务信息</span></span><br><span class="line">    <span class="type">InstanceInfo</span> <span class="variable">info</span> <span class="operator">=</span> eurekaClient.getNextServerFromEureka(<span class="string">&quot;SEARCH&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//2.获取到访问地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> info.getHomePageUrl();</span><br><span class="line">    System.out.println(url);</span><br><span class="line">    <span class="comment">//3.通过restTemplate访问</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(url + <span class="string">&quot;/search&quot;</span>, String.class);</span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Eureka的安全性"><a href="#Eureka的安全性" class="headerlink" title="Eureka的安全性"></a>Eureka的安全性</h3><p><strong>实现Eureka认证</strong></p><ul><li>导入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 忽略/eureka/**</span></span><br><span class="line">        http.csrf().ignoringAntMatchers(<span class="string">&quot;/eureka/**&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.configure(http);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><ul><li>其他服务想要注册到注册中心需要用户名密码</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定Eureka服务地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://username:password@localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="Eureka的高可用"><a href="#Eureka的高可用" class="headerlink" title="Eureka的高可用"></a>Eureka的高可用</h3><blockquote><p>如果程序正在运行，突然Eureka宕机了。</p><ol><li>如果调用方访问过一次被调用方，Eureka的宕机不会影响到功能。</li><li>如果调用方没有访问过被调用方，Eureka的宕机就会造成当前功能不可用。</li></ol></blockquote><p><strong>搭建Eureka高可用</strong></p><p>1、准备多台Eureka</p><blockquote><p>采用复制的方式，删除iml和target文件，并且修改pom.xml中的项目名称，再给父工程添加一个module</p></blockquote><p>2、让服务注册到多台Eureka</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://root:root@localhost:8761/eureka/,http://root:root@localhost:8762/eureka/</span></span><br></pre></td></tr></table></figure><p>3、让多台Eureka之间相互通讯</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">true</span>  <span class="comment">#注册到Eureka上</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span> <span class="comment">#从Eureka上拉取信息</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://root:root@$&#123;eureka.instance.hostname&#125;:8762/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="Eureka的细节"><a href="#Eureka的细节" class="headerlink" title="Eureka的细节"></a>Eureka的细节</h3><p>1、EurekaClient启动时，将自己的信息注册到EurekaServer上，EurekaServer就会存储EurekaClient的注册信息</p><p>2、当EurekaClient调用服务时，本地没有注册信息的缓存时，取EurekaServer中获取注册信息。</p><p>3、EurekaClient会通过心跳的方式和EurekaServer进行连接。（默认30s、EurekaClient会发送一次心跳请求，如果超过了90s还没有收到心跳信息的话，EurekaServer就认为EurekaClient节点宕机了，将当前的EurekaClient从注册表中移除）。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span>   <span class="comment">#心跳间隔</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span>    <span class="comment">#多久没有发送，就认为宕机</span></span><br></pre></td></tr></table></figure><p>4、EurekaClient会每隔30s去EurekaServer中去更新本地注册表</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span><span class="comment">#每隔多久去更新一下本地的注册表缓存信息</span></span><br></pre></td></tr></table></figure><p>5、Eureka的自我保护机制：统计15分钟内，如果一个服务的心跳发送比例低于85%，EurekaServer就会开启自我保护机制</p><ul><li>不会从EurekaServer中去移除长时间没有收到心跳的服务。</li><li>EurekaServer还是可以正常提供服务的。</li><li>网络比较稳定时，EurekaServer才会开始将自己的信息被其他节点同步过去。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">true</span>  <span class="comment">#开启自我保护机制</span></span><br></pre></td></tr></table></figure><p>6、CAP定理：C：一致性，A：可用性，P：分区容错性，这三个特性在分布式环境下，只能同时满足两个，而且分区容错性在分布式环境下是必须要满足的，只能在AC之间进行权衡。</p><p>如果选择了CP，保证了一致性可能会造成系统在一定时间内是不可用的。如果同步数据的时间比较长，将会造成很大的损失。</p><p>Eureka就是一个AP的效果，高可用的集群，Eureka集群是无中心，Eureka即便宕机几个也不会影响系统的使用，不需要重新的去推举一个master，但是他会导致一定时间内数据是不一致的。</p><h2 id="服务间的负载均衡：Ribbon"><a href="#服务间的负载均衡：Ribbon" class="headerlink" title="服务间的负载均衡：Ribbon"></a>服务间的负载均衡：Ribbon</h2><h3 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h3><blockquote><p>Ribbon是帮助我们实现服务和服务负载均衡，Ribbon属于客户端负载均衡</p><ul><li>客户端负载均衡：customer客户模块，将两个search模块信息全部拉取到本地的缓存，在customer中自己做一个负载均衡的策略，选中某一个服务。</li><li>服务端负载均衡：在注册中心中，直接根据你指定的负载均衡策略，帮你选中一个指定的服务信息，并返回。</li></ul></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201203112857670.png" alt="image-20201203112857670"></p><h3 id="Ribbon的快速入门"><a href="#Ribbon的快速入门" class="headerlink" title="Ribbon的快速入门"></a>Ribbon的快速入门</h3><p>1、启动两个search模块</p><p>2、在customer导入Ribbon依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、配置整合RestTemplate和Robbin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、在customer中访问search</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/customer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">customer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://SEARCH/search&quot;</span>, String.class);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ribbon配置负载均衡策略"><a href="#Ribbon配置负载均衡策略" class="headerlink" title="Ribbon配置负载均衡策略"></a>Ribbon配置负载均衡策略</h3><p>1、负载均衡策略</p><ul><li>RandomRule：随机策略</li><li>RoundRobinRule：轮询策略</li><li>WeightedResponseTimeRule：默认会采用轮询的策略，后续会根据服务的响应时间，自动分配权重</li><li>BestAvailableRule：根据被调用方并发数最小的去分配</li></ul><p>2、采用注解的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">robbinRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、配置文件指定负载均衡策略（推荐）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定具体服务的负载均衡策略</span></span><br><span class="line"><span class="attr">SEARCH:</span> <span class="comment">#编写服务名称</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.WeightedResponseTimeRule</span></span><br></pre></td></tr></table></figure><h2 id="服务间的调用：Feign"><a href="#服务间的调用：Feign" class="headerlink" title="服务间的调用：Feign"></a>服务间的调用：Feign</h2><h3 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h3><blockquote><p>Feign可以帮助我们实现面向接口编程，直接调用其他服务，简化开发。</p></blockquote><h3 id="Feign的快速入门"><a href="#Feign的快速入门" class="headerlink" title="Feign的快速入门"></a>Feign的快速入门</h3><p>·1、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、启动类添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br></pre></td></tr></table></figure><p>3、创建一个接口，并且和search模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FeignClient(&quot;SEARCH&quot;):指定服务名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;SEARCH&quot;)</span>      </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SearchClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * value -&gt;目标服务的请求路径，method -&gt; 映射请求方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/search&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    String <span class="title function_">search</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SearchClient searchClient;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/customer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">customer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> searchClient.search();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Feign的参数传递-方式"><a href="#Feign的参数传递-方式" class="headerlink" title="Feign的参数传递 方式"></a>Feign的参数传递 方式</h3><p>1、注意事项</p><ul><li>如果传递的参数比较复杂时，默认采用POST的请求方式。</li><li>传递单个参数时，推荐使用@PathVariable，如果传递的单个参数比较多，这里可以采用@RequestParam，不要省略value属性。</li><li>传递对象信息时，统一采用json方式，添加@RequestBody。</li><li>Client接口必须采用@RequestMapping</li></ul><p>2、在search模块下准备三个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/search/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id,<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getCustomer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">getCustomer</span><span class="params">(<span class="meta">@RequestParam</span> Integer id,<span class="meta">@RequestParam</span> String name)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id,name,<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Customer customer)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、封装customer模块下的controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/customer/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> searchClient.findById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getCustomer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">getCustomer</span><span class="params">(<span class="meta">@RequestParam</span> Integer id, <span class="meta">@RequestParam</span> String name)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> searchClient.getCustomer(id,name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Customer customer)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、再封装client接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/search/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">Customer <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(value = &quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/getCustomer&quot;,method = RequestMethod.GET)</span></span><br><span class="line">Customer <span class="title function_">getCustomer</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;)</span> Integer id, <span class="meta">@RequestParam(value = &quot;name&quot;)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/save&quot;,method = RequestMethod.POST)</span></span><br><span class="line">Customer <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Customer customer)</span>;</span><br></pre></td></tr></table></figure><h3 id="Feign的Fallback"><a href="#Feign的Fallback" class="headerlink" title="Feign的Fallback"></a>Feign的Fallback</h3><blockquote><p>Fallback可以帮助我们在使用Feign去调用另外一个服务时，如果出现了问题，走服务降级，返回一个错误数据，避免功能因为一个服务出现问题，全部失效。</p></blockquote><p>1、创建一个POJO类，实现Client接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchClientFallBack</span> <span class="keyword">implements</span> <span class="title class_">SearchClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">search</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;出现错误了&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">findById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">getCustomer</span><span class="params">(Integer id, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">save</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、修改Client接口中的注解，添加一个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;SEARCH&quot;,fallback = SearchClientFallBack.class)</span></span><br></pre></td></tr></table></figure><p>3、添加配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#feign和hystrix组件整合</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>以上方法存在的问题：调用方无法知道具体的错误信息是什么，通过FallBackFactory的方式去实现这个功能。</p></blockquote><p>1、FallBackFactory基于Fallback</p><p>2、创建一个POJO类，实现FallBackFactory<code>&lt;Client&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchClientFallBackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;SearchClient&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SearchClientFallBack searchClientFallBack;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SearchClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> searchClientFallBack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、修改Client接口属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;SEARCH&quot;,fallbackFactory = SearchClientFallBackFactory.class)</span></span><br></pre></td></tr></table></figure><h2 id="服务的隔离及熔断：Hystrix"><a href="#服务的隔离及熔断：Hystrix" class="headerlink" title="服务的隔离及熔断：Hystrix"></a>服务的隔离及熔断：Hystrix</h2><h3 id="引言-3"><a href="#引言-3" class="headerlink" title="引言"></a>引言</h3><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201204142948147.png" alt="image-20201204142948147"></p><h3 id="降级机制的实现"><a href="#降级机制的实现" class="headerlink" title="降级机制的实现"></a>降级机制的实现</h3><p>1、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、添加一个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br></pre></td></tr></table></figure><p>3、针对某一个接口去编写降级方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/customer/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;findByIdFallBack&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> searchClient.findById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * findById的降级方法，方法的描述要和接口一致</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">findByIdFallBack</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(-<span class="number">1</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、在接口上添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;findByIdFallBack&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h3><blockquote><p>如果使用tomcat的线程池去接收用户的请求，使用当前线程去执行其他服务的功能，如果某一个服务出现了故障，导致tomcat的线程大量的堆积，导致tomcat服务无法处理其他业务功能。</p><ul><li>Hystrix的线程池&#x3D;&#x3D;（默认）&#x3D;&#x3D;，接收用户请求采用tomcat的线程池，执行业务代码，调用其他服务时，采用Hystrix的线程池。</li><li>信号量，使用的还是tomcat的线程池，帮助我们去管理tomcat的线程池。</li></ul></blockquote><p>1、Hystrix的线程池的配置(具体的配置name属性需要查看HystrixCommandProperties类)</p><ul><li>线程隔离策略：name&#x3D;<code>hystrix.command.default.execution.isolation.strategy</code>,value&#x3D;<code>THREAD</code></li><li>指定超时时间（针对线程池）：name&#x3D;<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>,value&#x3D;<code>1000</code></li><li>是否开启超时时间配置：name&#x3D;<code>hystrix.command.default.execution.timeout.enabled</code>,value&#x3D;<code>true</code></li><li>超时之后是否中断线程：name&#x3D;<code>hystrix.command.default.execution.isolation.thread.interruptOnTimeout</code>,value&#x3D;<code>true</code></li><li>取消任务后是否中断线程：name&#x3D;<code>hystrix.command.default.execution.isolation.thread.interruptOnCancel</code>,value&#x3D;<code>false</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/customer/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;findByIdFallBack&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name=&quot;execution.isolation.strategy&quot;,value = &quot;THREAD&quot;),</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span><span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> searchClient.findById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、信号量的配置信息</p><ul><li><p>线程隔离策略：name&#x3D;<code>hystrix.command.default.execution.isolation.strategy</code>,value&#x3D;<code>SEMAPHORE</code></p></li><li><p>指定信号量的最大并发请求数：name&#x3D;<code>hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests</code>,value&#x3D;<code>10</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/customer/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;findByIdFallBack&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name=&quot;execution.isolation.strategy&quot;,value = &quot;SEMAPHORE&quot;),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span><span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> searchClient.findById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h3><h4 id="断路器介绍"><a href="#断路器介绍" class="headerlink" title="断路器介绍"></a>断路器介绍</h4><blockquote><p>在调用指定服务时，如果说这个服务的失败率达到输入的一个阈值，将断路器从closed状态，转变为open状态，指定服务是无法被访问的，如果访问就直接走fallback方法，在一定时间内，open状态会再次转变为half      open状态，允许一个请求发送到我指定的服务，如果成功，转变为closed，如果失败，服务再次转变为open状态，会再次循环到half open，直到断路器回到一个closed状态。</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201204162617695.png" alt="image-20201204162617695"></p><h4 id="配置断路器的监控界面"><a href="#配置断路器的监控界面" class="headerlink" title="配置断路器的监控界面"></a>配置断路器的监控界面</h4><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201205233318794.png" alt="image-20201205233318794"></p><p>1、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、启动类中添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure><p>3、配置一个servlet路径，指定上Hystrix的Servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/hystrix.stream&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixServlet</span> <span class="keyword">extends</span> <span class="title class_">HystrixMetricsStreamServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="comment">//在启动类上添加扫描servlet的注解</span></span><br></pre></td></tr></table></figure><h4 id="配置断路器的属性"><a href="#配置断路器的属性" class="headerlink" title="配置断路器的属性"></a>配置断路器的属性</h4><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201205235243369.png" alt="image-20201205235243369"></p><blockquote><p><a href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.enabled">详见官方文档</a></p></blockquote><p>断路器的属性(10秒钟之内)</p><ol><li>断路器开关：name&#x3D;<code>hystrix.command.default.circuitBreaker.enabled</code>,value&#x3D;<code>true</code></li><li>失败阈值的总请求数：name&#x3D;<code>hystrix.command.default.circuitBreaker.requestVolumeThreshold</code>,value&#x3D;<code>20</code></li><li>请求总数失败率达到<code>%</code>之多少时开启断路器：name&#x3D;<code>hystrix.command.default.circuitBreaker.errorThresholdPercentage</code>,value&#x3D;<code>50</code></li><li>断路器open状态后，多少秒是拒绝请求的：name&#x3D;<code>hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds</code>,value&#x3D;<code>5000</code></li><li>强制让服务拒绝请求：name&#x3D;<code>hystrix.command.default.circuitBreaker.forceOpen</code>,value&#x3D;<code>false</code></li><li>强制让服务接收请求：name&#x3D;<code>hystrix.command.default.circuitBreaker.forceClosed</code>,value&#x3D;<code>false</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;findByIdFallBack&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;70&quot;),</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;5000&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h3><h4 id="请求缓存的实现"><a href="#请求缓存的实现" class="headerlink" title="请求缓存的实现"></a>请求缓存的实现</h4><p>1、请求缓存的生命周期是一次请求</p><p>2、请求缓存时缓存当前线程中的一个方法，将方法的参数作为key，方法的返回结果作为value</p><p>3、在一次请求中，目标方法被调用过一次，以后就都会被缓存。</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201206000650027.png" alt="image-20201206000650027"></p><h4 id="请求缓存的实现-1"><a href="#请求缓存的实现-1" class="headerlink" title="请求缓存的实现"></a>请求缓存的实现</h4><p>1、创建一个service，在servie中调用search服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SearchClient searchClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheResult</span></span><br><span class="line">    <span class="meta">@HystrixCommand(commandKey = &quot;findById&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">findById</span><span class="params">(<span class="meta">@CacheKey</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchClient.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheRemove(commandKey = &quot;findById&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearFindById</span><span class="params">(<span class="meta">@CacheKey</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findById被清空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用请求缓存的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//帮助我们缓存当前方法的返回结果(必须配合HystrixCommand使用)</span></span><br><span class="line"><span class="meta">@CacheResult</span></span><br><span class="line"><span class="comment">//帮助我们清除某一个缓存信息(基于commandKey)</span></span><br><span class="line"><span class="meta">@CacheRemove</span></span><br><span class="line"><span class="comment">//指定方法的哪个参数作为缓存的标识，默认情况下是所有的参数</span></span><br><span class="line"><span class="meta">@CacheKey</span></span><br></pre></td></tr></table></figure><p> 3、修改search模块的返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id,<span class="string">&quot;张三&quot;</span>,(<span class="type">int</span>)(Math.random()*<span class="number">1000000</span>));</span><br></pre></td></tr></table></figure><p>4、编写Filter，去构建HystrixRequestContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixRequestContextInitFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        HystrixRequestContext.initializeContext();</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、修改control</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Customer <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(customerService.findById(id));</span><br><span class="line">    System.out.println(customerService.findById(id));</span><br><span class="line">    customerService.clearFindById(id);</span><br><span class="line">    System.out.println(customerService.findById(id));</span><br><span class="line">    System.out.println(customerService.findById(id));</span><br><span class="line">    <span class="keyword">return</span> searchClient.findById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、测试结果</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201206005450764.png" alt="image-20201206005450764"></p><h2 id="服务的网关：Zuul"><a href="#服务的网关：Zuul" class="headerlink" title="服务的网关：Zuul"></a>服务的网关：Zuul</h2><h3 id="引言-4"><a href="#引言-4" class="headerlink" title="引言"></a>引言</h3><blockquote><ul><li>客户端维护大量的ip和port信息，直接访问指定服务。</li><li>认证和授权操作，需要在每一个模块中都添加认证和授权的操作。</li><li>项目的迭代，服务要拆分，服务要合并，需要客户端进行大量的变化。</li><li>统一的把安全性校验都放在Zuul中。</li></ul></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201206143120641.png" alt="image-20201206143120641"></p><h3 id="Zuul的快速入门"><a href="#Zuul的快速入门" class="headerlink" title="Zuul的快速入门"></a>Zuul的快速入门</h3><p>1、创建maven项目，修改为springboot</p><p>2、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、添加一个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br></pre></td></tr></table></figure><p>4、编写配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定Eureka服务地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://root:root@localhost:8761/eureka/,http://root:root@localhost:8762/eureka/</span></span><br><span class="line"><span class="comment">#指定服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ZUUL</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="Zuul的常用配置信息"><a href="#Zuul的常用配置信息" class="headerlink" title="Zuul的常用配置信息"></a>Zuul的常用配置信息</h3><h4 id="Zuul的监控界面"><a href="#Zuul的监控界面" class="headerlink" title="Zuul的监控界面"></a>Zuul的监控界面</h4><p>1、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、编写配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看zuul的监控界面（开发时，配置为*，上线，不要配置）</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>3、直接访问</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201206145429176.png" alt="image-20201206145429176"></p><h4 id="忽略服务配置"><a href="#忽略服务配置" class="headerlink" title="忽略服务配置"></a>忽略服务配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#zuul配置</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="comment">#基于服务名忽略服务，无法查看，如果要忽略全部的服务，&quot;*&quot;，默认配置的全部路径都会被忽略掉（自定义</span></span><br><span class="line">  <span class="attr">ignored-services:</span> <span class="string">eureka</span></span><br><span class="line">  <span class="comment">#监控界面依然可以查看，在访问的时候，404</span></span><br><span class="line">  <span class="attr">ignored-patterns:</span> <span class="string">/**/search/**</span></span><br></pre></td></tr></table></figure><h4 id="自定义服务配置"><a href="#自定义服务配置" class="headerlink" title="自定义服务配置"></a>自定义服务配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定自定义服务(方式一，key（服务名）：value（路径））</span></span><br><span class="line"><span class="attr">routes:</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">/ss/**</span></span><br><span class="line">  <span class="attr">customer:</span> <span class="string">/cc/**</span></span><br><span class="line"> <span class="comment">#指定自定义服务(方式二）</span></span><br><span class="line"><span class="attr">routes:</span></span><br><span class="line">  <span class="attr">kehu:</span> <span class="comment">#自定义名称</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/ccc/**</span> <span class="comment">#映射的路径</span></span><br><span class="line">    <span class="attr">serviceId:</span> <span class="string">customer</span> <span class="comment">#服务名称</span></span><br></pre></td></tr></table></figure><h4 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h4><p>1、添加一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规定：</span></span><br><span class="line"><span class="comment"> *      服务的命名规则：服务名-v+版本号</span></span><br><span class="line"><span class="comment"> *      访问路径：/v+版本号/路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> PatternServiceRouteMapper <span class="title function_">serviceRouteMapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PatternServiceRouteMapper</span>(</span><br><span class="line">            <span class="string">&quot;(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;$&#123;version&#125;/$&#123;name&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、准备一个服务，提供两个版本</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version :</span> <span class="string">v1</span></span><br><span class="line"><span class="comment">#指定服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">CUSTOMER-$&#123;version&#125;</span></span><br></pre></td></tr></table></figure><p>3、修改Zuul的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#zuul配置</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="comment">#基于服务名忽略服务，无法查看,如果需要用的`-v`的方式，一定要忽略掉。</span></span><br><span class="line">  <span class="comment">#ignored-services: &quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>4、测试</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201206154702628.png" alt="image-20201206154702628"></p><h3 id="Zuul的过滤器执行流程"><a href="#Zuul的过滤器执行流程" class="headerlink" title="Zuul的过滤器执行流程"></a>Zuul的过滤器执行流程</h3><blockquote><p>客户端请求发送到zuul服务上，首先通过PreFilter链，如果正常放行，会把请求再次转发给RoutingFilter，请求转发到一个指定的服务，在指定的服务响应一个结果后，再次走一个PostFilter的过滤器链，最终再将响应信息交给客户端。</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201206155136998.png" alt="image-20201206155136998"></p><h3 id="Zuul过滤器入门"><a href="#Zuul过滤器入门" class="headerlink" title="Zuul过滤器入门"></a>Zuul过滤器入门</h3><p>1、创建一个POJO类，继承ZuulFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestZuulFilter2</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>2、指定当前过滤器类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> FilterConstants.PRE_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、指定过滤器的执行顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> FilterConstants.PRE_DECORATION_FILTER_ORDER -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、配置是否启用过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//开启当前过滤器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、指定过滤器中的具体业务代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;prifix过滤器执行~&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、测试</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201206160924248.png" alt="image-20201206160924248"></p><h3 id="PreFilter实现token检验"><a href="#PreFilter实现token检验" class="headerlink" title="PreFilter实现token检验"></a>PreFilter实现token检验</h3><p>1、准备访问路径，请求参数传递token</p><p><a href="http://localhost/v2/customer/version?token=123">http://localhost/v2/customer/version?token=123</a></p><p>2、创建AuthenticationFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_DECORATION_FILTER_ORDER - <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、在run方法中编写具体的业务逻辑代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123;</span><br><span class="line">        <span class="comment">//1.获取Request对象</span></span><br><span class="line">        <span class="type">RequestContext</span> <span class="variable">requestContext</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestContext.getRequest();</span><br><span class="line">        <span class="comment">//2.获取token参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">//3.对比token</span></span><br><span class="line">        <span class="keyword">if</span> (token ==<span class="literal">null</span> || !<span class="string">&quot;123&quot;</span>.equalsIgnoreCase(token))&#123;</span><br><span class="line">            <span class="comment">//4. token检验失败，直接响应数据</span></span><br><span class="line">            requestContext.setSendZuulResponse(<span class="literal">false</span>);</span><br><span class="line">            requestContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4、测试</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201206162522700.png" alt="image-20201206162522700"></p><h3 id="Zuul降级"><a href="#Zuul降级" class="headerlink" title="Zuul降级"></a>Zuul降级</h3><p>1、创建POJO类，实现接口FallbakProvider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZuulFallBack</span> <span class="keyword">implements</span> <span class="title class_">FallbackProvider</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>2、重写两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getRoute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//代表出现问题的服务，都走这个降级方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ClientHttpResponse <span class="title function_">fallbackResponse</span><span class="params">(String route, Throwable cause)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;降级的服务：&quot;</span> + route);</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientHttpResponse</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> HttpStatus <span class="title function_">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">//指定具体的HttpStatus</span></span><br><span class="line">            <span class="keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">//返回状态码</span></span><br><span class="line">            <span class="keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR.value();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">//指定错误信息</span></span><br><span class="line">            <span class="keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> InputStream <span class="title function_">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">//给用户响应的信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;当前服务：&quot;</span> + route + <span class="string">&quot;出现问题！！！&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> HttpHeaders <span class="title function_">getHeaders</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//指定响应头信息</span></span><br><span class="line">            <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">            headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">            <span class="keyword">return</span> headers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Zuul动态路由"><a href="#Zuul动态路由" class="headerlink" title="Zuul动态路由"></a>Zuul动态路由</h3><p>1、创建一个过滤器</p><blockquote><p>执行顺序最好放在Pre过滤器的最后面</p></blockquote><p>2、在run方法中编写业务逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123;</span><br><span class="line">    <span class="comment">//1.获取Request对象</span></span><br><span class="line">    <span class="type">RequestContext</span> <span class="variable">context</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> context.getRequest();</span><br><span class="line">    <span class="comment">//2.获取参数，redisKey</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;redisKey&quot;</span>);</span><br><span class="line">    <span class="comment">//3.直接判断</span></span><br><span class="line">    <span class="keyword">if</span> (redisKey !=<span class="literal">null</span> &amp;&amp; redisKey.equalsIgnoreCase(<span class="string">&quot;customer&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//http://localhost:8080/customer</span></span><br><span class="line">        context.put(FilterConstants.SERVICE_ID_KEY,<span class="string">&quot;customer-v1&quot;</span>);</span><br><span class="line">        context.put(FilterConstants.REQUEST_URI_KEY,<span class="string">&quot;/customer&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (redisKey !=<span class="literal">null</span> &amp;&amp; redisKey.equalsIgnoreCase(<span class="string">&quot;search&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//http://localhost:9090/search/1</span></span><br><span class="line">        context.put(FilterConstants.SERVICE_ID_KEY,<span class="string">&quot;search&quot;</span>);</span><br><span class="line">        context.put(FilterConstants.REQUEST_URI_KEY,<span class="string">&quot;/search/1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、测试</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201206174139484.png" alt="image-20201206174139484"></p><h2 id="多语言支持-Sidecar"><a href="#多语言支持-Sidecar" class="headerlink" title="多语言支持 Sidecar"></a>多语言支持 Sidecar</h2><h3 id="引言-5"><a href="#引言-5" class="headerlink" title="引言"></a>引言</h3><blockquote><p>在SpringCloud的项目中，需要接入一些非Java的程序，第三方接口，无法接入Eureka，Hystrix，Feign等等组件，启动一个代理的微服务，代理微服务去和非Java的程序或第三方接口交互，通过代理微服务去接入SpringCloud的相关组件。</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201207104917081.png" alt="image-20201207104917081"></p><h3 id="Sidecar实现"><a href="#Sidecar实现" class="headerlink" title="Sidecar实现"></a>Sidecar实现</h3><p>1、创建一个第三方的服务</p><blockquote><p>创建一个SpringBoot工程，并且添加一个Controller</p></blockquote><p>2、创建maven工程，修改spring Boot</p><p>3、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-sidecar<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableSidecar</span></span><br></pre></td></tr></table></figure><p>5、编写配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br><span class="line"><span class="comment"># 指定Eureka服务</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://root:root@localhost:8761/eureka,http://root:root@localhost:8762/eureka</span></span><br><span class="line"><span class="comment">#指定服务名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">other-service</span></span><br><span class="line"><span class="comment">#指定代理的第三方服务</span></span><br><span class="line"><span class="attr">sidecar:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br></pre></td></tr></table></figure><p>6、通过customer调用第三方服务</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201207113257702.png" alt="image-20201207113257702"></p><h2 id="服务间消息传递：Stream"><a href="#服务间消息传递：Stream" class="headerlink" title="服务间消息传递：Stream"></a>服务间消息传递：Stream</h2><h3 id="引言-6"><a href="#引言-6" class="headerlink" title="引言"></a>引言</h3><blockquote><p>用于构建消息驱动微服务的框架(在下面方便起见也叫它Stream框架)，该框架在Spring Boot的基础上整合了Spring Integration来连接消息代理中间件（RabbitMQ，Kafka等）。它支持多个消息中间件的自定义配置，同时吸收了这些消息中间件的部分概念，例如持久化订阅、消费者分组，和分区等概念。使用Stream框架，我们不必关心如何连接各个消息代理中间件，也不必关心消息的发送与接收，只需要进行简单的配置就可以实现这些功能了，可以让我们更敏捷的进行开发主体业务逻辑了。</p><p><strong>Spring Cloud Stream框架的组成部分：</strong></p><ol><li>Stream框架自己的应用模型；</li><li>绑定器抽象层，可以与消息代理中间件进行绑定，通过绑定器的API，可实现插件式的绑定器。</li><li>持久化订阅的支持。</li><li>消费者组的支持。</li><li>Topic分区的支持。</li></ol></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201207114808902.png" alt="image-20201207114808902"></p><h3 id="Stream快速入门"><a href="#Stream快速入门" class="headerlink" title="Stream快速入门"></a>Stream快速入门</h3><p>1、启动RabbitMQ</p><p>2、消费者-导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、消费者-配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 连接RabbitMQ</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.25</span><span class="number">.150</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p>4、消费者-监听的队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StreamClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Input(&quot;myMessage&quot;)</span></span><br><span class="line">    SubscribableChannel <span class="title function_">input</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableBinding(StreamClient.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(&quot;myMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">msg</span><span class="params">(Object msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、生产者-导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>6、生产者-配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 连接RabbitMQ</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.25</span><span class="number">.150</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p>7、生产者-发布消息</p><blockquote><p>需要在启动类中添加注解<code>@EnableBinding(StreamClient.class)</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StreamClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Output(&quot;myMessage&quot;)</span></span><br><span class="line">    MessageChannel <span class="title function_">output</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StreamClient streamClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        streamClient.output().send(MessageBuilder.withPayload(<span class="string">&quot;Hello Stream!!!&quot;</span>).build());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息发送成功！！！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream重复消费"><a href="#Stream重复消费" class="headerlink" title="Stream重复消费"></a>Stream重复消费</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">myMessage:</span><span class="comment">#队列名称</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">customer</span> <span class="comment">#消费者组</span></span><br></pre></td></tr></table></figure><h3 id="Stream的消费者手动ack"><a href="#Stream的消费者手动ack" class="headerlink" title="Stream的消费者手动ack"></a>Stream的消费者手动ack</h3><p>1、编写配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">stream:</span></span><br><span class="line">      <span class="comment">#手动实现ACK</span></span><br><span class="line">      <span class="attr">rabbit:</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">myMessage:</span></span><br><span class="line">            <span class="attr">consumer:</span></span><br><span class="line">              <span class="attr">acknowledgeMode:</span> <span class="string">MANUAL</span></span><br></pre></td></tr></table></figure><p>2、修改消费端的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StreamListener(&quot;myMessage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">msg</span><span class="params">(Object msg,</span></span><br><span class="line"><span class="params">                <span class="meta">@Header(name = AmqpHeaders.CHANNEL)</span> Channel channel,</span></span><br><span class="line"><span class="params">                <span class="meta">@Header(name = AmqpHeaders.DELIVERY_TAG)</span> Long deliveryTag)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">    channel.basicAck(deliveryTag,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务的动态配置：Config"><a href="#服务的动态配置：Config" class="headerlink" title="服务的动态配置：Config"></a>服务的动态配置：Config</h2><h3 id="引言-7"><a href="#引言-7" class="headerlink" title="引言"></a>引言</h3><blockquote><ul><li>配置文件分散在不通的项目中，不方便维护</li><li>配置文件的安全问题</li><li>修改完配置文件，无法立即生效</li></ul></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201207145400833.png" alt="image-20201207145400833"></p><h3 id="搭建Config-Server"><a href="#搭建Config-Server" class="headerlink" title="搭建Config-Server"></a>搭建Config-Server</h3><p>1、创建maven工程，修改为spring boot</p><p>2、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br></pre></td></tr></table></figure><p>4、编写配置文件(Git操作)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">basedir:</span> <span class="string">E:\Gitee\config</span>                         <span class="comment">#本地仓库</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">xuxueli982@163.com</span>                     <span class="comment">#远程仓库的用户名</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">Xxl@6553345726</span>                         <span class="comment">#远程仓库的密码</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://gitee.com/sabiler/config-repo.git</span>   <span class="comment">#远程仓库地址</span></span><br></pre></td></tr></table></figure><p>5、测试：</p><blockquote><p><code>http://localhost:port/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</code></p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201207170900983.png" alt="image-20201207170900983"></p><p>&#x3D;&#x3D;问题：&#x3D;&#x3D;配置好config-server服务后无法通过连接地址访问到远程git仓库中的配置文件</p><h3 id="修改customer连接Config"><a href="#修改customer连接Config" class="headerlink" title="修改customer连接Config"></a>修改customer连接Config</h3><p>1、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、编写配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定Eureka服务地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://root:root@localhost:8761/eureka/,http://root:root@localhost:8762/eureka/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">CUSTOMER-$&#123;version&#125;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">service-id:</span> <span class="string">CONFIG</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">version :</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure><p>3、修改配置名称</p><blockquote><p>bootstrap.yml</p></blockquote><p>4、测试发布消息到RabbitMQ</p><p><strong>PS：注意配置文件的文件名要和应用的名称相同并且区分大小写。</strong></p><h3 id="实现动态配置"><a href="#实现动态配置" class="headerlink" title="实现动态配置"></a>实现动态配置</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201207182600904.png" alt="image-20201207182600904"></p><h4 id="服务连接RabbitMQ"><a href="#服务连接RabbitMQ" class="headerlink" title="服务连接RabbitMQ"></a>服务连接RabbitMQ</h4><p>1、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、编写配置文件连接RabbitMQ</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.25</span><span class="number">.150</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h4 id="实现手动刷新"><a href="#实现手动刷新" class="headerlink" title="实现手动刷新"></a>实现手动刷新</h4><p>1、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、编写配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>3、为customer添加一个controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;env&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/env&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">env</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> env;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试</p><blockquote><ol><li>CONFIG在Gitee修改之后，自动拉取最新的配置信息</li><li>其他模块需要更新的话，需要手动给CONFIG应用发送一个请求：<code>http://localhost:8090/actuator/bus-refresh</code>，不重启项目，即可获取最新的配置信息</li></ol></blockquote><h4 id="实现自动刷新"><a href="#实现自动刷新" class="headerlink" title="实现自动刷新"></a>实现自动刷新</h4><p>1、配置Gitee中的WebHooks</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201207192516664.png" alt="image-20201207192516664"></p><p>添加完webhooks之后gitee会尝试发送一个请求给config应用，这时由于没有配置过滤器会报<code>400</code>错误码。</p><p>2、给Config添加一个过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrlFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest httpServletRequest= (HttpServletRequest) servletRequest;</span><br><span class="line">        String url=httpServletRequest.getRequestURI();</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        <span class="keyword">if</span>(!url.endsWith(<span class="string">&quot;/actuator/bus-refresh&quot;</span>))&#123;</span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String body=(httpServletRequest).toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;original body: &quot;</span>+ body);</span><br><span class="line">        RequestWrapper requestWrapper=<span class="keyword">new</span> <span class="title class_">RequestWrapper</span>(httpServletRequest);</span><br><span class="line">        filterChain.doFilter(requestWrapper,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">RequestWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">RequestWrapper</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">ServletInputStream</span> <span class="variable">servletInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletInputStream</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    <span class="keyword">return</span> byteArrayInputStream.read();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> byteArrayInputStream.read() == -<span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReadListener</span><span class="params">(ReadListener listener)</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> servletInputStream;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务的追踪：Sleuth"><a href="#服务的追踪：Sleuth" class="headerlink" title="服务的追踪：Sleuth"></a>服务的追踪：Sleuth</h2><h3 id="引言-8"><a href="#引言-8" class="headerlink" title="引言"></a>引言</h3><blockquote><p>在整个微服务架构中，微服务很多，一个请求可能需要调用很多很多的服务，最终才能完成一个功能，如果说，这个整个功能出现了问题，在这么多的服务中，如何去定位问题的所在点，出现问题的原因是什么。</p><p>1、Sleuth可以获得到整个服务链路的信息。</p><p>2、Zipkin通过图形化界面去看到信息。</p><p>3、Sleuth将日志信息存储到数据库中。</p></blockquote><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201207212921438.png" alt="image-20201207212921438"></p><h3 id="Sleuth使用"><a href="#Sleuth使用" class="headerlink" title="Sleuth使用"></a>Sleuth使用</h3><p>1、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、编写配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org.springframework.web.servlet.DispatcherServlet:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><p>3、测试</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201207215113742.png" alt="image-20201207215113742"></p><p>链路日志各个字段代表的含义：</p><ul><li>SEARCH：总链路id</li><li>516：当前服务链路id</li><li>false：不会将当前的日志信息输出到其他系统中\</li></ul><h3 id="Zipkin的使用"><a href="#Zipkin的使用" class="headerlink" title="Zipkin的使用"></a>Zipkin的使用</h3><p>1、搭建Zipkin的web工程</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.1&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">zipkin:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">daocloud.io/daocloud/zipkin:latest</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">zipkin</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9411</span><span class="string">:9411</span></span><br></pre></td></tr></table></figure><p>2、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、编写配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1</span>     <span class="comment">#代表百分之多少的sleuth信息需要输出到zipkin中</span></span><br><span class="line">    <span class="attr">zipkin:</span></span><br><span class="line">      <span class="attr">base-url:</span> <span class="string">http://192.168.25.150:9411/</span>   <span class="comment">#指定zipkin的地址</span></span><br></pre></td></tr></table></figure><p>4、测试</p><h3 id="整合RabbitMQ"><a href="#整合RabbitMQ" class="headerlink" title="整合RabbitMQ"></a>整合RabbitMQ</h3><p>1、导入RabbitMQ依赖</p><p>2、修改配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://192.168.25.150:9411/</span>   <span class="comment">#指定zipkin的地址</span></span><br><span class="line">    <span class="attr">sender:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">rabbit</span></span><br></pre></td></tr></table></figure><p>3、修改zipkin的信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.1&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">zipkin:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">daocloud.io/daocloud/zipkin:latest</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">zipkin</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9411</span><span class="string">:9411</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">RABBIT_ADDRESSES=192.168.25.150:5672</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">RABBIT_PASSWORD=test</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">RABBIT_USER=test</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">RABBIT_VIRTUAL_HOST=/</span></span><br></pre></td></tr></table></figure><p>4、测试</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201207231127086.png" alt="image-20201207231127086"></p><h3 id="Zipkin存储数据到ES"><a href="#Zipkin存储数据到ES" class="headerlink" title="Zipkin存储数据到ES"></a>Zipkin存储数据到ES</h3><p>1、重新修改zipkin的yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.1&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">zipkin:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">daocloud.io/daocloud/zipkin:latest</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">zipkin</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9411</span><span class="string">:9411</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">RABBIT_ADDRESSES=192.168.25.150:5672</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">RABBIT_PASSWORD=test</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">RABBIT_USER=test</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">RABBIT_VIRTUAL_HOST=/</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">STORAGE_TYPE=elasticsearch</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">ES_HOSTS=http://192.168.25.150:9200</span></span><br></pre></td></tr></table></figure><h2 id="完整SpringCloud架构图"><a href="#完整SpringCloud架构图" class="headerlink" title="完整SpringCloud架构图"></a>完整SpringCloud架构图</h2><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/image-20201207233028081.png" alt="image-20201207233028081"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringCloud介绍&quot;&gt;&lt;a href=&quot;#SpringCloud介绍&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud介绍&quot;&gt;&lt;/a&gt;SpringCloud介绍&lt;/h2&gt;&lt;h3 id=&quot;微服务架构&quot;&gt;&lt;a href=&quot;#微服务架</summary>
      
    
    
    
    <category term="分布式" scheme="http://www.xuxueli.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="SpringCloud" scheme="http://www.xuxueli.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Redis总结</title>
    <link href="http://www.xuxueli.top/2021/01/18/Redis/"/>
    <id>http://www.xuxueli.top/2021/01/18/Redis/</id>
    <published>2021-01-18T05:53:14.000Z</published>
    <updated>2022-05-22T09:35:59.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h3><p>&amp;emsp; Redis是<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver(远程数据服务)的缩写，由意大利人antirez(Salvatore Sanfilippo)开发的一款<strong>内存高速缓存数据库</strong>。该软件由C语言编写，他的数据模型为key-value，它支持丰富的数据结构（类型），比如：String、list、hash、set、sorted、set。可持久化，保证了数据安全。 </p><p>使用缓存减轻数据库的负载。</p><p>&amp;emsp; 在开发网站的时候如果有一些数据在短时间之内不会发生变化，而它们还要被频繁访问，为了提高用户的请求<strong>速度</strong>和<strong>降低网站的负载</strong>，就把这些数据放到一个读取速度更快的介质上（或者是通过较少的计算量就可以获得该数据），该行为就称为对该数据的缓存。该<strong>介质</strong>可以是文件、数据库、内存，内存经常用于数据缓存。</p><p>缓存的两种形式：</p><ul><li>页面缓存：经常用在CMS(content manage system)内存管理系统里面。</li><li>数据缓存：经常会用在页面的具体数据里面。</li></ul><h3 id="Redis-和memcache比较"><a href="#Redis-和memcache比较" class="headerlink" title="Redis 和memcache比较"></a>Redis 和memcache比较</h3><ol><li>Redis不仅支持简单的k-v类型的数据，同时还提供list、set、zset、hash等数据结构的存储。</li><li>Redis支持master-slave（主从一致）模式应用。</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis单个value的最大限制是1GB，memcached只能保存1MB的数据。</li></ol><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><ol><li><p>redis启动脚本的细节</p><p> 直接使用<code>./redis-server</code>方式启动使用的redis-server这个shell脚本中默认配置。</p></li><li><p>如何在启动redis时指定配置文件启动</p><p> 默认在redis安装完成之后在安装目录没有任何配置文件，需要到源码目录中复制redis.conf配置文件到安装目录下</p></li><li><p>修改redis默认的端口号</p></li></ol><p>redis-cli：终端操作脚本。</p><p>redis-server：启动redis服务脚本文件。</p><p>redis-benchmark：压力测试文件。</p><p>redis-check-aof和redis-check-dump：检测备份文件脚本。</p><h3 id="redis中库的概念"><a href="#redis中库的概念" class="headerlink" title="redis中库的概念"></a>redis中库的概念</h3><p><strong>库</strong></p><p>&amp;emsp;database是用来存放数据的一个基本单元，一个库可以存放key-value键值对 redis中每一个库都有一个唯一名称（编号）从0开始，默认库的个数：16个库。库的编号：0-15，默认使用的是0号库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Set the number of databases. The default database is DB 0, you can select</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a different one on a per-connection basis using SELECT &lt;dbid&gt; <span class="built_in">where</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dbid is a number between 0 and <span class="string">&#x27;databases&#x27;</span>-1</span></span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure><p>切换库的命令：SELECT <dbid>(库编号)</p><p>redis中清除库的指令：</p><ul><li>flushDB清空当前库</li><li>flushAll     清空所有库</li></ul><h2 id="Redis数据库相关指令"><a href="#Redis数据库相关指令" class="headerlink" title="Redis数据库相关指令"></a>Redis数据库相关指令</h2><h3 id="数据库操作指令"><a href="#数据库操作指令" class="headerlink" title="数据库操作指令"></a>数据库操作指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.Redis中库说明</span></span><br><span class="line">- 使用redis的默认配置启动redis服务后，默认会存在16个库，编号从0-15</span><br><span class="line">- 可以使用select库的编号来选择一个redis的库</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.Redis中操作库的指令</span></span><br><span class="line">- 清空当前的库FLUSHDB</span><br><span class="line">- 清空全部的库FLUSHALL</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. redis客户端显示中文</span></span><br><span class="line">- ./redis-cli-p6379--raw</span><br></pre></td></tr></table></figure><h3 id="操作key相关指令"><a href="#操作key相关指令" class="headerlink" title="操作key相关指令"></a>操作key相关指令</h3><p>在redis中，除了<code>\n</code>和空格不能作为名字的组成内容外，其他内容都可以作为key的名字部分，名字长度不做要求。</p><table><thead><tr><th align="center">指令</th><th align="center">语法</th><th align="center">作用</th><th align="center">可用版本</th><th align="center">返回值</th><th>其他</th></tr></thead><tbody><tr><td align="center">del</td><td align="center"><code>del key[key ...]</code></td><td align="center">删除给定的一个或多个key。不存在key会被忽略。</td><td align="center">&gt;&#x3D;1.0.0</td><td align="center">被删除key的数量</td><td></td></tr><tr><td align="center">exists</td><td align="center"><code>exists key</code></td><td align="center">检查给定key是否存在</td><td align="center">&gt;&#x3D;1.0.0</td><td align="center">若key存在，返回1，否则返回0。</td><td></td></tr><tr><td align="center">expire</td><td align="center"><code>expire key seconds</code></td><td align="center">为给定key设置生存时间，当key过期时（生存时间为0),它会被自动删除。</td><td align="center">&gt;&#x3D;1.0.0</td><td align="center">设置成功返回1。</td><td>时间复杂度：O(1)</td></tr><tr><td align="center">keys</td><td align="center"><code>keys pattern</code></td><td align="center">查找所有符合给定模式patter的key。</td><td align="center">&gt;&#x3D;1.0.0</td><td align="center">符合给定模式的key列表。</td><td><code>keys *</code> 匹配数据库中所有key。<code>keys h?llo</code> 匹配<code>hello,hallo,hxllo</code>等。<code>keys h*llo</code>, 匹配<code>hllo</code>和<code>heeeello</code>等。<code>keys h[ae]llo</code>, 匹配<code>hello</code>和<code>hallo</code>，但不匹配<code>hillo</code>，特殊符号用<code>\</code>隔开。</td></tr><tr><td align="center">move</td><td align="center"><code>move key db</code></td><td align="center">将当前数据库的key移动到给定的数据库DB中。</td><td align="center">&gt;&#x3D;1.0.0</td><td align="center">移动成功返回1，失败则返回0。</td><td></td></tr><tr><td align="center">pexpire</td><td align="center"><code>pexpire key milliseconds</code></td><td align="center">这个命令和<code>expire</code>命令的作用类似，但是它以毫秒为单位设置key的生存时间，而不像<code>expire</code>命令那样，以秒为单位。</td><td align="center">&gt;&#x3D;2.6.0</td><td align="center">设置成功返回1，key不存在或设置失败返回0。</td><td>时间复杂度：o(1)</td></tr><tr><td align="center">pexpireat</td><td align="center"><code>pexpireat key milliseconds-timestamp</code></td><td align="center">这个命令和<code>expire</code>命令类似，但它以毫秒为单位设置key的过期unix时间戳，而不是像<code>expire</code>那样，以秒为单位。</td><td align="center">&gt;&#x3D;2.6.0</td><td align="center">如果生存时间设置成功，返回1。当key不存在或没办法设置生存时间时，返回0。（查看<code>expire</code>命令获取更多信息）</td><td></td></tr><tr><td align="center">ttl</td><td align="center"><code>ttl key</code></td><td align="center">以秒为单位，返回给定key的剩余生存时间（TTL，time to live)。</td><td align="center">&gt;&#x3D;1.0.0</td><td align="center">当key不存在时，返回-2。当key存在但没有设置剩余生存时间是，返回-1。否则，以秒为单位，返回key的剩余生存时间。</td><td>在Redis 2.8 以前，当key不存在，或者key没有设置剩余生存时间时，命令都返回-1。</td></tr><tr><td align="center"><code>pttl</code></td><td align="center"><code>pttl key</code></td><td align="center">这个命令类似于<code>ttl</code>命令，但它以毫秒为单位返回key的剩余生存时间而不是像<code>ttl</code>命令那样，以秒为单位。</td><td align="center">&gt;&#x3D;2.6.0</td><td align="center">当key不存在时，返回-2，当key存在但没有设置剩余生存时间返回-1，否则以毫秒为单位，返回key的剩余生存时间。</td><td>在Redis 2.8以前,当key不存在，或者key没有设置剩余生存时间时，命令都返回-1。</td></tr><tr><td align="center">randomkey</td><td align="center"><code>randomkey</code></td><td align="center">从当前数据库中随机返回（不删除）一个key。</td><td align="center">&gt;&#x3D;1.0.0</td><td align="center">当数据库不为空时，返回一个key。当数据库为空时，返回nil。</td><td></td></tr><tr><td align="center">rename</td><td align="center"><code>rename key newkey</code></td><td align="center">将key改名为newkey，当key和newkey相同，或者key不存在时，返回一个错误。当newkey已经存在时，rename命令将覆盖旧值。</td><td align="center">&gt;&#x3D;1.0.0</td><td align="center">改名成功提示OK，失败时返回错误</td><td></td></tr><tr><td align="center">type</td><td align="center"><code>type key</code></td><td align="center">返回key所存储的值的类型。</td><td align="center">&gt;&#x3D; 1.0.0</td><td align="center">none(key不存在)String(字符串)，List(列表)Set(集合)ZSet(有序集)Hash(哈希表)</td><td></td></tr></tbody></table><h3 id="String-类型操作"><a href="#String-类型操作" class="headerlink" title="String 类型操作"></a>String 类型操作</h3><blockquote><p><code>String</code>是<code>redis</code>最基本的类型，<code>redis</code>的<code>String</code>可以包含任何数据。包括jpg或者序列化的都对象。单个value值最大上限是1GB。  </p></blockquote><h4 id="内存存储模型"><a href="#内存存储模型" class="headerlink" title="内存存储模型"></a>内存存储模型</h4><table><thead><tr><th align="center">KEY</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">张三</td></tr><tr><td align="center">age</td><td align="center">20</td></tr></tbody></table><h4 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>set</td><td>设置一个key&#x2F;value</td></tr><tr><td>get</td><td>根据key获得对应的value</td></tr><tr><td>mset</td><td>一次设置多个key &#x2F;value</td></tr><tr><td>mget</td><td>一次获得多个key的value</td></tr><tr><td>getset</td><td>获得原始key的值，同时设置新值</td></tr><tr><td>strlen</td><td>获得对应key存储value的长度</td></tr><tr><td>append</td><td>为对应key的value追加内容</td></tr><tr><td>getrange索引0开始</td><td>截取value内容</td></tr><tr><td>setex</td><td>设置一个key存活的有效期（秒）</td></tr><tr><td>psetex</td><td>设置一个key存活的的有效期（毫秒）</td></tr><tr><td>setnx</td><td>存在不做任何操作，不存在添加</td></tr><tr><td>msetnx原子操作（只能有一个存在不做任何操作）</td><td>可以同时设置多个key,只要有一个存在都不保存</td></tr><tr><td>decr</td><td>进行数值类型的-1操作</td></tr><tr><td>decrby</td><td>根据提供的数据进行减法操作</td></tr><tr><td>incr</td><td>进行数值类型的+1操作</td></tr><tr><td>incrby</td><td>根据提供的数据类型进行加法操作</td></tr><tr><td>incrbyfloat</td><td>根据提供的数据加入浮点数</td></tr></tbody></table><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>&amp;emsp; list列表相当于Java中list集合特点：元素有序且可以重复</p><h4 id="内存存储模型-1"><a href="#内存存储模型-1" class="headerlink" title="内存存储模型"></a>内存存储模型</h4><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20200929230846635.png" alt="image-20200929230846635"></p><h4 id="常用操作指令"><a href="#常用操作指令" class="headerlink" title="常用操作指令"></a>常用操作指令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>lpush</td><td>将某个值加入到一个key列表头部</td></tr><tr><td>lpushx（x：exists)</td><td>同lpush，但是必须保证这个key存在</td></tr><tr><td>rpush</td><td>将某个值加入到一个key列表末尾</td></tr><tr><td>rpushx</td><td>同rpush，但是必须保证这个key存在</td></tr><tr><td>lpop</td><td>返回和移除列表的第一个元素</td></tr><tr><td>rpop</td><td>返回和移除列表的第一个元素</td></tr><tr><td>lrange 0 -1</td><td>获取某一个下标区间内的元素</td></tr><tr><td>llen</td><td>获取列表元素个数</td></tr><tr><td>lset</td><td>设置某一个指定索引的值（索引必须存在）</td></tr><tr><td>lindex</td><td>获取某一指定索引位置的元素</td></tr><tr><td>lrem</td><td>删除重复元素</td></tr><tr><td>ltrim</td><td>保留列表中特定区间内的元素</td></tr><tr><td>linsert</td><td>在某一个元素之前，之后插入新元素</td></tr></tbody></table><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>&amp;emsp; 特点：set类型set集合 元素无序 不可以重复</p><h4 id="内存存储模型-2"><a href="#内存存储模型-2" class="headerlink" title="内存存储模型"></a>内存存储模型</h4><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20200929234000826.png" alt="image-20200929234000826"></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>常用命令</th><th>说明</th></tr></thead><tbody><tr><td>sadd</td><td>为集合添加元素</td></tr><tr><td>smembers</td><td>显示集合中所有元素（无序）</td></tr><tr><td>scard</td><td>返回集合中元素的个数</td></tr><tr><td>spop</td><td>随机返回一个元素并将元素在集合中删除</td></tr><tr><td>smove</td><td>从一个集合中向另一个集合移动元素</td></tr><tr><td>srem</td><td>从集合中删除一个元素</td></tr><tr><td>sismember</td><td>判断一个集合中是否含有这个元素</td></tr><tr><td>srandmember</td><td>随机返回元素</td></tr><tr><td>sdiff</td><td>去掉第一个集合中其它集合中含有的相同元素</td></tr><tr><td>sinter</td><td>求交集</td></tr><tr><td>sunion</td><td>求合集</td></tr></tbody></table><h3 id="ZSet类型"><a href="#ZSet类型" class="headerlink" title="ZSet类型"></a>ZSet类型</h3><p>&amp;emsp; 特点：可排序的set集合，排序，不可重复</p><p>&amp;emsp; ZSET官方，可排序SET，sortSet</p><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20200930000218342.png" alt="image-20200930000218342"></p><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>zadd</td><td>添加一个有序集合元素</td></tr><tr><td>zcard</td><td>返回集合的元素个数</td></tr><tr><td>zrange升序zrevrange降序</td><td>返回一个范围内的元素</td></tr><tr><td>zrangebyscore</td><td>按照分数查找一个范围内的元素</td></tr><tr><td>zrank</td><td>返回排名</td></tr><tr><td>zrevrank</td><td>倒序排名</td></tr><tr><td>zscore</td><td>显示某一个元素的分数</td></tr><tr><td>zrem</td><td>移除某一个元素</td></tr><tr><td>zincrby</td><td>给某个特定元素加分</td></tr></tbody></table><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>&amp;emsp; 特点：value是一个map结构 存在key-valuekey无序的</p><h4 id="内存模型-1"><a href="#内存模型-1" class="headerlink" title="内存模型"></a>内存模型</h4><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20200930001919773.png" alt="image-20200930001919773"></p><h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>hset</td><td>设置一个key&#x2F;value对</td></tr><tr><td>hget</td><td>获得一个key对应的value</td></tr><tr><td>hgetall</td><td>获得所有的key&#x2F;value对</td></tr><tr><td>hdel</td><td>删除某一个key&#x2F;value对</td></tr><tr><td>hexists</td><td>判断一个key是否存在</td></tr><tr><td>hkeys</td><td>获得所有的key</td></tr><tr><td>hvals</td><td>获得所有的value</td></tr><tr><td>hmset</td><td>设置多个key&#x2F;value</td></tr><tr><td>hmget</td><td>获得多个key的value</td></tr><tr><td>hsetnx</td><td>设置一个不存在的key值</td></tr><tr><td>hincrby</td><td>为value进行加法运算</td></tr><tr><td>hincrbyfloat</td><td>为value加入浮点值</td></tr></tbody></table><p> 开启redis远程连接</p><p>&amp;emsp;注意：默认redis服务器是没有开启远程连接，也就是默认拒绝所有远程客户端连接。</p><ul><li>修改配置开启远程连接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf #修改如下配置</span><br><span class="line">bind 0.0.0.0 #允许一切客户端连接</span><br></pre></td></tr></table></figure><ul><li>修改配置之后重启redis服务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../redis.conf #注意：一定要加载配置文件启动。</span><br></pre></td></tr></table></figure><h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>client redis(内存)———-&gt;内存数据————-&gt;数据持久化———–&gt;磁盘</p><p>Redis官方提供了两种不同的持久化方法来将数据存储到硬盘里面。</p><ul><li>快照（<code>snapshot</code>）</li><li>AOF(<code>Append Only File</code>)只追加日志文件</li></ul><h3 id="快照：Snapshot"><a href="#快照：Snapshot" class="headerlink" title="快照：Snapshot"></a>快照：Snapshot</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>&amp;emsp; 这种方式可以将某一时刻的所有数据都写入硬盘中，当然这也是<strong>redis默认的开启持久化方式</strong>，保存的文件是以<code>.rdb</code>形式结尾的文件因此这种方式也称之为<code>RDB</code>方式。</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20201005212101824.png" alt="image-20201005212101824"></p><h4 id="快照的生成方式"><a href="#快照的生成方式" class="headerlink" title="快照的生成方式"></a>快照的生成方式</h4><p><strong>1.客户端方式之：BGSAVE</strong></p><p>&amp;emsp;客户端可以使用<code>BGSAVE</code>指令来创建一个快照，当接收到客户端的<code>BGSAVE</code>命令时，<code>redis</code>会调用<code>fork</code>来创建一个子进程，然后子进程负责将快照写入磁盘中，而父进程则继续处理命令请求。</p><p>&amp;emsp;名词解释<code>fork</code>：当一个进程创建子进程的时候，底层的操作系统会创建该进程的一个副本，在类unix系统中创建子进程的操作会进行优化，在刚开始的时候，父进程共享相同内容，直到父进程或子进程进行了写之后，对被写入的内存的共享才会结束服务。</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20201005214834920.png" alt="image-20201005214834920"></p><p><strong>2. 客户端：SAVE</strong></p><p>&amp;emsp;客户端还可以使用SAVE命令来创建一个快照，接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他命令</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20201005215219398.png" alt="image-20201005215219398"></p><ul><li>注意：SAVE命令并不常用，使用SAVE命令在快照创建完毕之前，redis处于阻塞状态，无法对外提供服务。</li></ul><p><strong>3. 服务器配置方式满足配置自动 触发</strong></p><p>&amp;emsp;如果用户在<code>redis.conf</code>中设置了<code>save</code>配置选项，<code>redis</code>会在<code>save</code>选项条件满足之后自动触发一次<code>BGSAVE</code>命令，如果设置了多个<code>save</code>配置选项，当任意一个<code>save</code>配置选项条件满足，<code>redis</code>也会触发一次<code>BGSAVE</code>。</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20201011230449509.png" alt="image-20201011230449509"></p><p><strong>4. 服务器接收客户端shutdown指令</strong></p><p>&amp;emsp; 当<code>redis</code>通过<code>shutdown</code>指令接收到关闭服务器的请求时，会执行一个<code>save</code>命令，阻塞所有的客户端，不再执行客户端发送的任何命令，并且在<code>save</code>命令执行完毕之后关闭服务器。</p><h4 id="配置生成快照名称和位置"><a href="#配置生成快照名称和位置" class="headerlink" title="配置生成快照名称和位置"></a>配置生成快照名称和位置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.修改生成快照名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.修改生成位置</span></span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><h3 id="AOF只追加日志文件"><a href="#AOF只追加日志文件" class="headerlink" title="AOF只追加日志文件"></a>AOF只追加日志文件</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>&amp;emsp; 这种方式可以将所有客户端执行的写命令记录到日志文件中，AOF持久化会将被执行的写命令写道AOF的文件末尾，以此来记录数据发生的变化，因此只要redis从头到尾执行一次AOF文件包含的所有写命令，就可以恢复AOF文件记录的数据集。</p><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20201011212058673.png" alt="image-20201011212058673"></p><h4 id="开启AOF持久化"><a href="#开启AOF持久化" class="headerlink" title="开启AOF持久化"></a>开启AOF持久化</h4><p>&amp;emsp; 在<code>redis</code>的默认配置中<code>AOF</code>持久化机制是没有开启的，需要在配置中开启。</p><p>开启AOF持久化</p><ol><li>修改<code>appendonlyyes</code>开启持久化</li><li>修改<code>appendfilename    &quot;appendonly.aof&quot;    </code>指定生成文件名称。</li><li>默认appendonly.aof是存储在与快照中指定的<code>dir ./</code>相同的目录下的。</li></ol><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20201011222233735.png" alt="image-20201011222233735"></p><h4 id="日志追加频率"><a href="#日志追加频率" class="headerlink" title="日志追加频率"></a>日志追加频率</h4><p><strong>always [谨慎使用]</strong></p><ul><li>说明：每个redis写命令都要同步写入硬盘，严重降低redis速度。</li><li>解释：如果用户使用always选项，那么每个redis写命令的都会被写入硬盘，从而将发生系统崩溃时出现的数据丢失减到最小；遗憾的是：因为这种同步策略需要对硬盘进行大量的写入操作，所以redis处理命令的速度会受到硬盘性能的限制；</li><li>‼注意：转盘式硬盘在这种频率下200左右个命令&#x2F;s，固态硬盘（SSD）几百万个命令&#x2F;s。</li><li>⚠警告：使用SSD用户请谨慎使用always选项，这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题，导致将固态硬盘的寿命从原来的几年降低为几个月。</li></ul><p><strong>everysec [推荐]</strong></p><ul><li>说明：每秒执行一次同步，显示的将多个写命令同步到磁盘。</li><li>解释：为了兼顾数据安全和写入性能，用户可以考虑使用everysec选项，让redis每秒一次的频率对AOF文件进行同步；redis每秒同步一次AOF文件时性能和不使用任何持久化特性时的性能相差无几，而通过每秒钟同步一次AOF文件，redis可以保证，即使系统崩溃时，用户最多丢失一秒内产生的数据。</li></ul><p><strong>no [不推荐]</strong></p><ul><li>说明：由操作系统决定何时同步</li><li>解释：最后使用no选项，将完全由操作系统决定是什么时候同步AOF日志文件，这个选项不会对redis性能带来影响，但是系统崩溃时，会丢失不定量的数据；另外如果用户硬盘处理写入操作不够快的话，当缓冲区被等待写入硬盘数据填满时，redis会处于阻塞状态，并导致redis的处理命令请求的速度变慢。</li></ul><h3 id="AOF文件的重写"><a href="#AOF文件的重写" class="headerlink" title="AOF文件的重写"></a>AOF文件的重写</h3><h4 id="AOF带来的问题"><a href="#AOF带来的问题" class="headerlink" title="AOF带来的问题"></a>AOF带来的问题</h4><p>&amp;emsp; AOF大方式也同时带来了另一个问题，持久化文件会变得越来越大。例如我们调用incr test命令100次，文件中就必须保存全部的100条命令，其实有99条都是多余的，因为要恢复数据库的状态其实文件中保存一条<code>set test 100</code>就够了，为了压缩aof的持久化文件Redis提供了AOF重写（ReWriter)机制。</p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><blockquote><p>用来在一定程度上减少AOF文件的体积。</p></blockquote><h4 id="触发重写方式"><a href="#触发重写方式" class="headerlink" title="触发重写方式"></a>触发重写方式</h4><p><strong>客户端方式触发重写</strong></p><p>&amp;emsp; 执行<code>BGREWRITEAOF</code>命令，不会阻塞redis服务</p><p><strong>服务器配置方式自动触发</strong></p><ul><li>配置<code>redis.conf</code>中的<code>auto-aof-rewrite-percentage</code>选项，参见下图↓↓↓</li></ul><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20201011222116791.png" alt="image-20201011222116791"></p><ul><li>如果设置<code>auto-aof-rewrite-percentage</code>值为100和<code>auto-aof-rewrite-min-size 64mb</code>,并且启用的AOF持久化机制，那么当AOF文件体积大于64M，并且AOF文件体积比上一次重写之后体积大了至少一倍（100%)时，会自动触发，如果重写过于频繁，用户可以考虑将<code>auto-aof-rewrite-percentage</code>设置为更大。</li></ul><h4 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h4><p>&amp;emsp;&#x3D;&#x3D;注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写一个新的aof文件，替换原有的文件这点和快照有点类似。&#x3D;&#x3D;</p><p><strong>重写流程</strong></p><ol><li><code>redis</code>调用<code>fork</code>，现在有父子两个进程，子进程根据内存中的数据快照，往临时文件中写入重建数据库状态的命令。</li><li>父进程继续处理client对象，除了把写命令写入到原来的<code>aof</code>文件中，同时把接收到的写命令缓存起来，这样就能保证如果子进程重写失败的话并不会出现问题。</li><li>当子进程把快照内容以命令方式写入到临时文件中之后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件中。<strong>思考一个问题：如果父进程开始将缓存的写命令也写入到临时文件时这时候父进程会不会阻塞，即此时不响应客户端的写入请求。</strong></li><li>现在父进程可以使用临时文件替换老的<code>aof</code>文件，并重写命名，后面收到的写命令也开始往新的<code>aof</code>文件中追加。</li></ol><hr><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20201011224016694.png" alt="image-20201011224016694"></p><h4 id="持久化总结"><a href="#持久化总结" class="headerlink" title="持久化总结"></a>持久化总结</h4><p>&amp;emsp; 两种持久化方案既可以同时使用(<code>aof</code>),也可以单独使用，在某种情况下也可以都不使用。具体使用哪种持久化方案取决于用户的数据和应用决定。</p><p>&amp;emsp; 无论使用AOF还是使用快照机制持久化，将数据持久化到硬盘都是必要的。除了持久化外，用户还应该对持久化的文件进行备份（最好备份在多个不同的地方）。</p><h2 id="Java操作Redis"><a href="#Java操作Redis" class="headerlink" title="Java操作Redis"></a>Java操作Redis</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><strong>1. 引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入jedis连接依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 创建Jedis对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Jedis对象</span></span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.25.150&quot;</span>,<span class="string">&quot;6379&quot;</span>);</span><br><span class="line">jedis.select(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//执行相关操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//释放连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h3 id="操-作key相关API"><a href="#操-作key相关API" class="headerlink" title="操 作key相关API"></a>操 作key相关API</h3><h3 id="操作String相关API"><a href="#操作String相关API" class="headerlink" title="操作String相关API"></a>操作String相关API</h3><h3 id="操作List相关API"><a href="#操作List相关API" class="headerlink" title="操作List相关API"></a>操作List相关API</h3><h3 id="操作Set相关API"><a href="#操作Set相关API" class="headerlink" title="操作Set相关API"></a>操作Set相关API</h3><h3 id="操作Hash相关API"><a href="#操作Hash相关API" class="headerlink" title="操作Hash相关API"></a>操作Hash相关API</h3><h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><p>&amp;emsp; Spring Boot Data（数据）Redis中提供了<strong>RedisTemplate和StringRedisTemplate</strong>,其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致。不同之处主要体现在操作的数据类型不同，<strong>RedisTemplate中的两个泛型都是Object，意味着存储<code>key</code>和<code>value</code>都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的<code>key</code>和<code>value</code>都只能是字符串。</strong></p><p>&amp;emsp;<strong>注意：使用RedsiTemplate默认是将对象序列化到Redis中，所以放入的对象必须实现对象序列化接口。</strong></p><h3 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h3><p> <strong>1.引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入依赖 spring data redis 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主从复制架构仅仅用来解决数据冗余备份，从节点仅仅用来同步数据。</p><blockquote><p>主从架构存在的问题：</p><ul><li>无法解决主节点宕机后的自动故障转移问题。</li></ul></blockquote><h3 id="主从复制架构图"><a href="#主从复制架构图" class="headerlink" title="主从复制架构图"></a>主从复制架构图</h3><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20201022221516243.png" alt="image-20201022221516243"></p><h3 id="搭建主从复制"><a href="#搭建主从复制" class="headerlink" title="搭建主从复制"></a>搭建主从复制</h3><p><strong>准备3台机器并修改配置</strong></p><blockquote><ul><li><code>master</code><ul><li>port 6379</li><li>bind 0.0.0.0</li></ul></li><li><code>slave1</code><ul><li>port 6380</li><li>bind 0.0.0.0</li><li>slaveof <masterip> <masterport></li></ul></li><li><code>slave2</code><ul><li>port 6381</li><li>bind 0.0.0.0</li><li>slaveof <masterip> <masterport></li></ul></li></ul></blockquote><h2 id="Redis哨兵机制"><a href="#Redis哨兵机制" class="headerlink" title="Redis哨兵机制"></a>Redis哨兵机制</h2><h3 id="哨兵Sentine机制"><a href="#哨兵Sentine机制" class="headerlink" title="哨兵Sentine机制"></a>哨兵Sentine机制</h3><p>&amp;emsp;Sentine(哨兵)是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器下属的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器下属的某个从服务器升级为新的主服务器。简单的说哨兵就是带有自动故障转移功能的主从架构。</p><h3 id="哨兵架构原理"><a href="#哨兵架构原理" class="headerlink" title="哨兵架构原理"></a>哨兵架构原理</h3><p><img src="https://picgo-xuexueli.oss-cn-beijing.aliyuncs.com/images/middleware/redis/image-20201022224855604.png" alt="image-20201022224855604"></p><h3 id="哨兵模式的搭建"><a href="#哨兵模式的搭建" class="headerlink" title="哨兵模式的搭建"></a>哨兵模式的搭建</h3><p><strong>1. 主节点创建哨兵配置</strong></p><blockquote><p>再Master对应的redis.conf同目录下新建sentinel.conf文件，名字绝对不能错。</p></blockquote><p><strong>2. 配置哨兵，再sentinel.conf文件中填入内容</strong></p><blockquote><p>sentinel monitor 被监视的主从架构别名（自己定义）ip port 1</p><ul><li>说明：数字1代表有一个及以上的sentinel服务检测到master宕机，才会执行主从切换的功能。</li></ul></blockquote><p><strong>3.启动哨兵模式进行测试</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-sentinel /root/sentinel/sentinel.conf</span><br></pre></td></tr></table></figure><blockquote><p>哨兵架构存在的问题</p><ul><li><p>单节点的并发压力问题</p></li><li><p>单节点的内存和磁盘的物理上限问题</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;什么是Redis&quot;&gt;&lt;a href=&quot;#什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;什么是Redis&quot;</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.xuxueli.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Redis" scheme="http://www.xuxueli.top/tags/Redis/"/>
    
  </entry>
  
</feed>
